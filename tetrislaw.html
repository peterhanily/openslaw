<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetrislaw â€” OpenSlaw.ai</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Inter', sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem 1rem 0.5rem;
        }
        .game-header { text-align: center; margin-bottom: 0.5rem; }
        .game-header h1 { font-size: 1.8rem; font-weight: 800; }
        .game-header h1 span { color: #4ade80; }
        .game-header p { color: #94a3b8; font-size: 0.85rem; margin-top: 0.25rem; }
        .hud {
            display: flex; gap: 1.5rem; justify-content: center;
            margin-bottom: 0.5rem; flex-wrap: wrap;
        }
        .hud-item { text-align: center; }
        .hud-label { font-size: 0.6rem; font-weight: 700; color: #64748b; text-transform: uppercase; letter-spacing: 0.05em; }
        .hud-val { font-size: 1.1rem; font-weight: 800; }
        .hud-val.green { color: #4ade80; }
        .game-wrap {
            display: flex; gap: 0.75rem; align-items: flex-start;
        }
        .game-container {
            border-radius: 1rem; overflow: hidden;
            box-shadow: 0 0 60px rgba(22,163,74,0.15), 0 0 0 1px rgba(255,255,255,0.05);
        }
        canvas#board { display: block; touch-action: manipulation; max-width: 100%; height: auto; }
        .next-box {
            background: #1e293b; border-radius: 0.5rem; padding: 0.5rem;
            border: 1px solid rgba(255,255,255,0.05);
            display: flex; flex-direction: column; align-items: center;
        }
        .next-box canvas { display: block; margin-top: 0.25rem; }
        .touch-controls {
            display: none; justify-content: center; gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .touch-btn {
            width: 56px; height: 50px;
            background: transparent; border: 2px solid #4ade80;
            border-radius: 0.75rem; color: #4ade80;
            font-size: 1.3rem; cursor: pointer;
            user-select: none; -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            display: flex; align-items: center; justify-content: center;
        }
        .touch-btn:active { background: rgba(74,222,128,0.15); }
        @media (pointer: coarse) { .touch-controls { display: flex; } .controls-hint { display: none; } }
        .game-footer { text-align: center; margin-top: 0.75rem; }
        .game-footer a { color: #4ade80; text-decoration: none; font-weight: 600; font-size: 0.9rem; }
        .game-footer a:hover { text-decoration: underline; }
        .controls-hint { color: #64748b; font-size: 0.75rem; margin-top: 0.5rem; }
        .toast-container {
            position: fixed; top: 1rem; left: 50%; transform: translateX(-50%);
            z-index: 100; display: flex; flex-direction: column; align-items: center;
            gap: 0.5rem; pointer-events: none;
        }
        .toast {
            background: rgba(15,23,42,0.95); border: 1px solid #4ade80; color: #4ade80;
            padding: 0.5rem 1.25rem; border-radius: 0.5rem; font-size: 0.85rem; font-weight: 700;
            animation: toastIn 0.3s ease, toastOut 0.3s ease 2s forwards; white-space: nowrap;
        }
        @keyframes toastIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes toastOut { from { opacity: 1; } to { opacity: 0; } }
        @media (max-width: 600px) {
            body { padding: 0.5rem 0.5rem 0.25rem; }
            .game-header h1 { font-size: 1.3rem; }
            .game-header p { display: none; }
            .hud { gap: 1rem; }
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>Tetris<span>law</span></h1>
        <p>Stack the slaw. Clear the lines. Become the Lobster Whisperer.</p>
    </div>
    <div class="hud">
        <div class="hud-item"><div class="hud-label">Score</div><div class="hud-val" id="hScore">0</div></div>
        <div class="hud-item"><div class="hud-label">Level</div><div class="hud-val green" id="hLevel">1</div></div>
        <div class="hud-item"><div class="hud-label">Lines</div><div class="hud-val" id="hLines">0</div></div>
        <div class="hud-item"><div class="hud-label">Best</div><div class="hud-val" id="hBest">0</div></div>
        <div class="hud-item">
            <div class="hud-label">Next</div>
            <div class="next-box"><canvas id="nextC" width="80" height="80"></canvas></div>
        </div>
    </div>
    <div class="game-container">
        <canvas id="board" width="300" height="600"></canvas>
    </div>
    <div class="touch-controls">
        <button class="touch-btn" id="bL">&#9664;</button>
        <button class="touch-btn" id="bR">&#8635;</button>
        <button class="touch-btn" id="bD">&#9660;</button>
        <button class="touch-btn" id="bDrop">&#9196;</button>
        <button class="touch-btn" id="bRt">&#9654;</button>
    </div>
    <div class="game-footer">
        <a href="/">&larr; Back to OpenSlaw.ai</a>
        <div class="controls-hint">Arrow keys &middot; Up=Rotate &middot; Space=Hard Drop</div>
    </div>
    <div class="toast-container" id="toasts"></div>

<script>
'use strict';

const COLS = 10, ROWS = 20, CELL = 30;
const W = COLS * CELL, H = ROWS * CELL;
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const nCanvas = document.getElementById('nextC');
const nCtx = nCanvas.getContext('2d');

// Pieces: I O T S Z L J
const SHAPES = [
    [[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],[[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]],[[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]],
    [[[1,1],[1,1]],[[1,1],[1,1]],[[1,1],[1,1]],[[1,1],[1,1]]],
    [[[0,1,0],[1,1,1],[0,0,0]],[[0,1,0],[0,1,1],[0,1,0]],[[0,0,0],[1,1,1],[0,1,0]],[[0,1,0],[1,1,0],[0,1,0]]],
    [[[0,1,1],[1,1,0],[0,0,0]],[[0,1,0],[0,1,1],[0,0,1]],[[0,0,0],[0,1,1],[1,1,0]],[[1,0,0],[1,1,0],[0,1,0]]],
    [[[1,1,0],[0,1,1],[0,0,0]],[[0,0,1],[0,1,1],[0,1,0]],[[0,0,0],[1,1,0],[0,1,1]],[[0,1,0],[1,1,0],[1,0,0]]],
    [[[0,0,1],[1,1,1],[0,0,0]],[[0,1,0],[0,1,0],[0,1,1]],[[0,0,0],[1,1,1],[1,0,0]],[[1,1,0],[0,1,0],[0,1,0]]],
    [[[1,0,0],[1,1,1],[0,0,0]],[[0,1,1],[0,1,0],[0,1,0]],[[0,0,0],[1,1,1],[0,0,1]],[[0,1,0],[0,1,0],[1,1,0]]]
];
const COLORS = ['#f97316','#eab308','#4ade80','#15803d','#ef4444','#dc2626','#0d9488'];
const NAMES = ['I','O','T','S','Z','L','J'];

const LEVEL_NAMES = {1:'Line Cook',2:'Sous Chef',3:'Head Chef',5:'Lobster Whisperer',8:'AGC'};
const LINE_MSG = [null,
    ['Nice chop!','Clean slice!','One line!'],
    ['Double dice!','Two-layer dip!'],
    ['Triple julienne!','Chef\'s special!'],
    ['\u{1F99E} LOBSTER TETRIS!','\u{1F99E} QUADRUPLE SLAW!']
];

let board, cur, nextType, score, level, linesCleared, best, state, dropT, lastT, clearAnim, bag;

function init() {
    best = 0;
    try { best = parseInt(localStorage.getItem('tetrislaw-best')) || 0; } catch(e) {}
    state = 'start';
    document.getElementById('hBest').textContent = best;
    lastT = performance.now();
    loop(lastT);
}

function startGame() {
    board = [];
    for (let r = 0; r < ROWS; r++) board.push(new Array(COLS).fill(0));
    score = 0; level = 1; linesCleared = 0; dropT = 0; clearAnim = null;
    bag = [];
    fillBag();
    nextType = popBag();
    cur = spawn(popBag());
    nextType = popBag();
    drawNext();
    updateHud();
    state = 'playing';
    toast('\u{1F96C} Level 1: Line Cook');
}

// Bag
function fillBag() {
    bag = [0,1,2,3,4,5,6];
    for (let i = 6; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [bag[i],bag[j]]=[bag[j],bag[i]]; }
}
function popBag() { if (!bag.length) fillBag(); return bag.pop(); }

// Piece
function spawn(t) {
    const s = SHAPES[t][0];
    return { t, r: 0, x: Math.floor((COLS - s[0].length) / 2), y: 0 };
}
function shape(t, r) { return SHAPES[t][r]; }
function hit(t, r, px, py) {
    const s = shape(t, r);
    for (let row = 0; row < s.length; row++)
        for (let col = 0; col < s[row].length; col++) {
            if (!s[row][col]) continue;
            const bx = px + col, by = py + row;
            if (bx < 0 || bx >= COLS || by >= ROWS) return true;
            if (by >= 0 && board[by][bx]) return true;
        }
    return false;
}
function lock() {
    const s = shape(cur.t, cur.r), c = COLORS[cur.t];
    for (let row = 0; row < s.length; row++)
        for (let col = 0; col < s[row].length; col++) {
            if (!s[row][col]) continue;
            const bx = cur.x + col, by = cur.y + row;
            if (by >= 0 && by < ROWS && bx >= 0 && bx < COLS) board[by][bx] = c;
        }
}

// Movement
function moveL() { if (cur && state==='playing' && !clearAnim && !hit(cur.t,cur.r,cur.x-1,cur.y)) cur.x--; }
function moveR() { if (cur && state==='playing' && !clearAnim && !hit(cur.t,cur.r,cur.x+1,cur.y)) cur.x++; }
function moveD() {
    if (!cur || state!=='playing' || clearAnim) return;
    if (!hit(cur.t,cur.r,cur.x,cur.y+1)) { cur.y++; score++; updateHud(); dropT=0; }
}
function drop() {
    if (!cur || state!=='playing' || clearAnim) return;
    let n = 0;
    while (!hit(cur.t,cur.r,cur.x,cur.y+1)) { cur.y++; n++; }
    score += n * 2; updateHud(); place();
}
function rot() {
    if (!cur || state!=='playing' || clearAnim) return;
    const nr = (cur.r + 1) % 4;
    const kicks = NAMES[cur.t]==='I' ? [0,-1,1,-2,2] : [0,-1,1];
    for (const k of kicks) if (!hit(cur.t,nr,cur.x+k,cur.y)) { cur.r=nr; cur.x+=k; return; }
}

function place() {
    lock();
    const full = [];
    for (let r = 0; r < ROWS; r++) if (board[r].every(c => c !== 0)) full.push(r);
    if (full.length) { clearAnim = { rows: full, f: 0 }; }
    else spawnNext();
}
function spawnNext() {
    cur = spawn(nextType);
    nextType = popBag();
    drawNext();
    if (hit(cur.t, cur.r, cur.x, cur.y)) {
        state = 'gameover';
        if (score > best) { best = score; try { localStorage.setItem('tetrislaw-best', best); } catch(e) {} }
        updateHud();
    }
    dropT = 0;
}
function scoreRows(n) {
    const pts = [0,100,300,500,800];
    score += pts[n] * level;
    linesCleared += n;
    const nl = Math.floor(linesCleared / 10) + 1;
    if (nl > level) { level = nl; toast('\u{1F4C8} Level '+level+(LEVEL_NAMES[level]?': '+LEVEL_NAMES[level]:'!')); }
    if (n > 0 && n <= 4) { const m = LINE_MSG[n]; toast(m[Math.floor(Math.random()*m.length)]); }
    if (score > best) { best = score; try { localStorage.setItem('tetrislaw-best', best); } catch(e) {} }
    updateHud();
}
function ghostRow() {
    if (!cur) return 0;
    let gy = cur.y;
    while (!hit(cur.t, cur.r, cur.x, gy + 1)) gy++;
    return gy;
}
function dropSpeed() { return Math.max(100, 800 - (level - 1) * 60); }

// HUD
function updateHud() {
    document.getElementById('hScore').textContent = score;
    document.getElementById('hLevel').textContent = level;
    document.getElementById('hLines').textContent = linesCleared;
    document.getElementById('hBest').textContent = best;
}
function toast(msg) {
    const el = document.createElement('div');
    el.className = 'toast'; el.textContent = msg;
    document.getElementById('toasts').appendChild(el);
    setTimeout(() => el.remove(), 2500);
}

// Drawing
function drawCell(cx, x, y, color, a) {
    cx.globalAlpha = a || 1;
    cx.fillStyle = color;
    cx.fillRect(x*CELL+1, y*CELL+1, CELL-2, CELL-2);
    cx.fillStyle = 'rgba(255,255,255,0.18)';
    cx.fillRect(x*CELL+1, y*CELL+1, CELL-2, 3);
    cx.fillRect(x*CELL+1, y*CELL+1, 3, CELL-2);
    cx.fillStyle = 'rgba(0,0,0,0.3)';
    cx.fillRect(x*CELL+CELL-3, y*CELL+1, 2, CELL-2);
    cx.fillRect(x*CELL+1, y*CELL+CELL-3, CELL-2, 2);
    cx.globalAlpha = 1;
}
function draw() {
    // Board bg
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    // Grid
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 1;
    for (let r = 0; r <= ROWS; r++) { ctx.beginPath(); ctx.moveTo(0,r*CELL+.5); ctx.lineTo(W,r*CELL+.5); ctx.stroke(); }
    for (let c = 0; c <= COLS; c++) { ctx.beginPath(); ctx.moveTo(c*CELL+.5,0); ctx.lineTo(c*CELL+.5,H); ctx.stroke(); }
    // Locked cells
    for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++)
            if (board && board[r][c]) {
                if (clearAnim && clearAnim.rows.includes(r)) {
                    const flash = Math.sin(clearAnim.f / 12 * Math.PI);
                    ctx.fillStyle = 'rgba(255,255,255,'+(flash*0.8)+')';
                    ctx.fillRect(c*CELL, r*CELL, CELL, CELL);
                } else {
                    drawCell(ctx, c, r, board[r][c]);
                }
            }
    // Ghost + current
    if (state === 'playing' && cur && !clearAnim) {
        const gy = ghostRow();
        if (gy !== cur.y) {
            const s = shape(cur.t, cur.r);
            for (let r = 0; r < s.length; r++)
                for (let c = 0; c < s[r].length; c++)
                    if (s[r][c] && gy+r >= 0) drawCell(ctx, cur.x+c, gy+r, COLORS[cur.t], 0.2);
        }
        const s2 = shape(cur.t, cur.r);
        for (let r = 0; r < s2.length; r++)
            for (let c = 0; c < s2[r].length; c++)
                if (s2[r][c] && cur.y+r >= 0) drawCell(ctx, cur.x+c, cur.y+r, COLORS[cur.t]);
    }
    // Overlays
    if (state === 'start') drawOverlay('Tetrislaw', ['Stack the slaw pieces','Arrow keys to move','Up = Rotate  Space = Drop','Clear lines to level up!','','Press Space or tap to start']);
    else if (state === 'gameover') drawOverlay('Game Over', ['Score: '+score,'Lines: '+linesCleared,'Level: '+level,'Best: '+best,'','Press Space or tap to play again']);
}
function drawOverlay(title, lines) {
    ctx.fillStyle = 'rgba(15,23,42,0.88)';
    ctx.fillRect(0, 0, W, H);
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const cw = 240, ch = 50 + lines.length * 26;
    const cx = (W-cw)/2, cy = (H-ch)/2 - 10;
    ctx.fillStyle = '#1e293b'; ctx.strokeStyle = 'rgba(74,222,128,0.3)'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx+12,cy); ctx.lineTo(cx+cw-12,cy); ctx.quadraticCurveTo(cx+cw,cy,cx+cw,cy+12);
    ctx.lineTo(cx+cw,cy+ch-12); ctx.quadraticCurveTo(cx+cw,cy+ch,cx+cw-12,cy+ch);
    ctx.lineTo(cx+12,cy+ch); ctx.quadraticCurveTo(cx,cy+ch,cx,cy+ch-12);
    ctx.lineTo(cx,cy+12); ctx.quadraticCurveTo(cx,cy,cx+12,cy);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#4ade80'; ctx.font = '800 22px Inter,sans-serif';
    ctx.fillText(title, W/2, cy + 28);
    ctx.font = '600 13px Inter,sans-serif';
    for (let i = 0; i < lines.length; i++) {
        ctx.fillStyle = lines[i].startsWith('Best') ? '#4ade80' : (lines[i].startsWith('Press') || lines[i].startsWith('Tap') ? '#64748b' : '#e2e8f0');
        ctx.fillText(lines[i], W/2, cy + 58 + i * 26);
    }
}
function drawNext() {
    nCtx.clearRect(0, 0, nCanvas.width, nCanvas.height);
    const s = shape(nextType, 0), col = COLORS[nextType];
    const sz = 16, h = s.length, w = s[0].length;
    const ox = (nCanvas.width - w*sz)/2, oy = (nCanvas.height - h*sz)/2;
    for (let r = 0; r < h; r++)
        for (let c = 0; c < w; c++) {
            if (!s[r][c]) continue;
            const px = ox+c*sz, py = oy+r*sz;
            nCtx.fillStyle = col;
            nCtx.fillRect(px+1,py+1,sz-2,sz-2);
            nCtx.fillStyle = 'rgba(255,255,255,0.18)';
            nCtx.fillRect(px+1,py+1,sz-2,2); nCtx.fillRect(px+1,py+1,2,sz-2);
            nCtx.fillStyle = 'rgba(0,0,0,0.3)';
            nCtx.fillRect(px+sz-3,py+1,2,sz-2); nCtx.fillRect(px+1,py+sz-3,sz-2,2);
        }
}

// Game loop
function loop(ts) {
    const dt = ts - lastT;
    lastT = ts;
    if (state === 'playing') {
        if (clearAnim) {
            clearAnim.f++;
            if (clearAnim.f >= 12) {
                const n = clearAnim.rows.length;
                clearAnim.rows.sort((a,b)=>a-b);
                for (let i = clearAnim.rows.length-1; i >= 0; i--) board.splice(clearAnim.rows[i], 1);
                for (let i = 0; i < n; i++) board.unshift(new Array(COLS).fill(0));
                scoreRows(n);
                clearAnim = null;
                spawnNext();
            }
        } else {
            dropT += dt;
            if (dropT >= dropSpeed()) {
                dropT = 0;
                if (cur && !hit(cur.t,cur.r,cur.x,cur.y+1)) cur.y++;
                else if (cur) place();
            }
        }
    }
    draw();
    requestAnimationFrame(loop);
}

// --- Input ---
function handleStart() {
    if (state === 'start' || state === 'gameover') { startGame(); return true; }
    return false;
}

document.addEventListener('keydown', e => {
    if (e.key === ' ' || e.code === 'Space') {
        e.preventDefault();
        if (handleStart()) return;
        if (state === 'playing') drop();
        return;
    }
    if (handleStart()) return;
    if (state !== 'playing') return;
    switch (e.code || e.key) {
        case 'ArrowLeft': case 'Left': e.preventDefault(); moveL(); break;
        case 'ArrowRight': case 'Right': e.preventDefault(); moveR(); break;
        case 'ArrowDown': case 'Down': e.preventDefault(); moveD(); break;
        case 'ArrowUp': case 'Up': e.preventDefault(); rot(); break;
    }
});

canvas.addEventListener('click', () => handleStart());

// Touch: canvas
let tX = 0, tY = 0, tTime = 0, tMoved = false;
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (handleStart()) return;
    if (state !== 'playing') return;
    const t = e.touches[0];
    tX = t.clientX; tY = t.clientY; tTime = Date.now(); tMoved = false;
}, { passive: false });
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (state !== 'playing') return;
    const t = e.touches[0];
    const dx = t.clientX - tX, dy = t.clientY - tY;
    if (Math.abs(dx) > 30 && Math.abs(dx) > Math.abs(dy)) {
        tMoved = true;
        dx > 0 ? moveR() : moveL();
        tX = t.clientX; tY = t.clientY;
    } else if (dy > 30 && Math.abs(dy) > Math.abs(dx)) {
        tMoved = true; moveD(); tY = t.clientY;
    }
}, { passive: false });
canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if (state === 'playing' && !tMoved && Date.now() - tTime < 250) rot();
}, { passive: false });

// Touch buttons
function setupBtn(id, fn) {
    const btn = document.getElementById(id);
    let iv = null;
    const doIt = e => {
        e.preventDefault();
        if (handleStart()) return;
        if (state === 'playing') {
            fn();
            if (id === 'bL' || id === 'bRt' || id === 'bD') {
                clearInterval(iv);
                iv = setInterval(() => { if (state === 'playing') fn(); }, 80);
            }
        }
    };
    const stop = e => { e.preventDefault(); clearInterval(iv); iv = null; };
    btn.addEventListener('touchstart', doIt, { passive: false });
    btn.addEventListener('touchend', stop, { passive: false });
    btn.addEventListener('touchcancel', stop, { passive: false });
    btn.addEventListener('mousedown', e => { e.preventDefault(); if (handleStart()) return; if (state==='playing') fn(); });
}
setupBtn('bL', moveL);
setupBtn('bRt', moveR);
setupBtn('bR', rot);
setupBtn('bD', moveD);
setupBtn('bDrop', drop);

// Prevent page scroll from touch-controls area
document.querySelector('.touch-controls').addEventListener('touchmove', e => e.preventDefault(), { passive: false });

// Go
init();
</script>
</body>
</html>
