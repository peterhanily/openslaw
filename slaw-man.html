<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Slaw-Man — OpenSlaw.ai</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }

        .game-header {
            text-align: center;
            margin-bottom: 1rem;
        }

        .game-header h1 {
            font-size: 1.5rem;
            font-weight: 800;
            letter-spacing: -0.02em;
        }

        .game-header h1 span { color: #4ade80; }

        .game-header p {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 0.25rem;
        }

        .game-container {
            position: relative;
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(22, 163, 74, 0.15), 0 0 0 1px rgba(255,255,255,0.05);
        }

        .game-container::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.03) 0px,
                rgba(0, 0, 0, 0.03) 1px,
                transparent 1px,
                transparent 3px
            );
            pointer-events: none;
            z-index: 1;
            border-radius: 1rem;
        }

        canvas {
            display: block;
            touch-action: manipulation;
            max-width: 100%;
            height: auto;
        }

        .game-footer {
            text-align: center;
            margin-top: 1rem;
        }

        .game-footer a {
            color: #4ade80;
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .game-footer a:hover { text-decoration: underline; }

        .controls-hint {
            font-size: 0.75rem;
            color: #64748b;
            margin-top: 0.5rem;
        }

        .touch-controls {
            display: none;
            justify-content: center;
            gap: 0.6rem;
            margin-top: 0.8rem;
        }

        .touch-btn {
            width: 64px;
            height: 56px;
            border-radius: 12px;
            border: 2px solid rgba(74,222,128,0.3);
            background: rgba(15,23,42,0.8);
            color: #4ade80;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        .touch-btn:active {
            background: rgba(74,222,128,0.2);
            border-color: #4ade80;
        }

        @media (pointer:coarse),(max-width:520px) {
            .touch-controls { display: flex; }
        }

        .toast-container {
            position: fixed;
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            pointer-events: none;
        }

        .toast {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid #4ade80;
            color: #4ade80;
            padding: 0.6rem 1.2rem;
            border-radius: 0.5rem;
            font-size: 0.85rem;
            font-weight: 600;
            animation: toastIn 0.3s ease, toastOut 0.3s ease 2s forwards;
            white-space: nowrap;
        }

        @keyframes toastIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes toastOut { from { opacity: 1; } to { opacity: 0; } }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>Slaw-<span>Man</span></h1>
        <p>Chomp the maze. Avoid the condiments.</p>
    </div>
    <div class="game-container">
        <canvas id="game" width="460" height="540"></canvas>
    </div>
    <div class="touch-controls">
        <button class="touch-btn" id="btn-left">&#9664;</button>
        <button class="touch-btn" id="btn-up">&#9650;</button>
        <button class="touch-btn" id="btn-down">&#9660;</button>
        <button class="touch-btn" id="btn-right">&#9654;</button>
    </div>
    <div class="game-footer">
        <a href="/">&larr; Back to OpenSlaw.ai</a>
        <div class="controls-hint">Arrow keys / WASD &bull; Space to start</div>
    </div>
    <div class="toast-container" id="toastContainer"></div>

    <script>
    (function() {
        'use strict';

        var canvas = document.getElementById('game');
        var ctx = canvas.getContext('2d');
        var W = 460, H = 540;
        var COLS = 23, ROWS = 27, CELL = 20;

        // State machine
        var MENU = 0, READY = 1, PLAYING = 2, DYING = 3, LEVEL_COMPLETE = 4, INTERMISSION = 5, GAME_OVER = 6;
        var state = MENU;

        // Directions: 0=right, 1=down, 2=left, 3=up
        var DX = [1, 0, -1, 0];
        var DY = [0, 1, 0, -1];

        // Maze: 0=wall, 1=dot, 2=empty, 3=power pellet
        var MAZE_TEMPLATE = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0],
            [0,3,0,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,0,3,0],
            [0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,0,0,1,0,0,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0],
            [0,1,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0],
            [0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0],
            [0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,0,0],
            [0,0,0,0,1,0,1,0,0,0,2,0,2,0,0,0,1,0,1,0,0,0,0],
            [1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1],
            [0,0,0,0,1,0,1,0,2,2,2,2,2,2,2,0,1,0,1,0,0,0,0],
            [0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0],
            [0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0],
            [0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,0],
            [0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0],
            [0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0],
            [0,1,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0],
            [0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0],
            [0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],
            [0,3,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,3,0],
            [0,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        ];

        // Ghost definitions — classic Pac-Man analogs with coleslaw parody
        var GHOST_DEFS = [
            { name: 'Mayonnaise', nick: 'The Emulsifier', color: '#f1f5f9', desc: 'Hunts you directly', corner: { col: 1, row: 1 } },
            { name: 'Ranch', nick: 'The Rebrander', color: '#f9a8d4', desc: 'Ambushes from ahead', corner: { col: 21, row: 1 } },
            { name: 'Raisin', nick: 'The Intruder', color: '#a855f7', desc: 'Wildly unpredictable', corner: { col: 1, row: 25 } },
            { name: 'Thousand Island', nick: 'The Compromiser', color: '#fb923c', desc: 'Shy but persistent', corner: { col: 21, row: 25 } }
        ];

        // Coleslaw ingredients (fruit replacements) by level
        var INGREDIENTS = [
            { name: 'Cabbage Head', pts: 100, emoji: '\u{1F96C}' },
            { name: 'Carrot', pts: 200, emoji: '\u{1F955}' },
            { name: 'Vinegar Bottle', pts: 300, emoji: '\u{1F3F6}' },
            { name: 'Celery Seed', pts: 400, emoji: '\u{1F331}' },
            { name: 'Mustard Jar', pts: 500, emoji: '\u{1F7E1}' },
            { name: 'Peppercorn', pts: 700, emoji: '\u26AB' },
            { name: 'Sugar Cube', pts: 1000, emoji: '\u{1F9CA}' },
            { name: 'Golden Slaw Bowl', pts: 2000, emoji: '\u{1F957}' }
        ];

        // Maze state
        var maze = [];
        var totalDots = 0;
        var dotsEaten = 0;

        function resetMaze() {
            maze = [];
            totalDots = 0;
            dotsEaten = 0;
            for (var r = 0; r < ROWS; r++) {
                maze[r] = [];
                for (var c = 0; c < COLS; c++) {
                    maze[r][c] = MAZE_TEMPLATE[r][c];
                    if (maze[r][c] === 1 || maze[r][c] === 3) totalDots++;
                }
            }
        }

        // Player
        var PLAYER_START = { col: 11, row: 20 };
        var player = {
            col: 11, row: 20, dir: 0, nextDir: 0,
            moveTimer: 0, moveInterval: 150,
            mouthAngle: 0, mouthDir: 1,
            lives: 3, score: 0, extraLifeGiven: false
        };

        function resetPlayer() {
            player.col = PLAYER_START.col;
            player.row = PLAYER_START.row;
            player.dir = 2; // face left (classic)
            player.nextDir = 2;
            player.moveTimer = 0;
            player.mouthAngle = 0;
            player.mouthDir = 1;
        }

        // Ghosts
        var ghosts = [];

        function createGhost(i) {
            return {
                idx: i, col: 10 + i, row: 10 + (i === 0 ? 0 : 1),
                dir: i % 2 === 0 ? 0 : 2,
                moveTimer: 0, moveInterval: 170,
                mode: 'house', houseTimer: i * 2500,
                frightenedTimer: 0,
                color: GHOST_DEFS[i].color,
                name: GHOST_DEFS[i].name,
                corner: GHOST_DEFS[i].corner
            };
        }

        function resetGhosts() {
            ghosts = [];
            for (var i = 0; i < 4; i++) ghosts.push(createGhost(i));
        }

        // Mode schedule (scatter/chase cycle)
        var MODE_SCHEDULE = [
            { mode: 'scatter', duration: 7000 },
            { mode: 'chase', duration: 20000 },
            { mode: 'scatter', duration: 7000 },
            { mode: 'chase', duration: 20000 },
            { mode: 'scatter', duration: 5000 },
            { mode: 'chase', duration: 20000 },
            { mode: 'scatter', duration: 5000 },
            { mode: 'chase', duration: Infinity }
        ];
        var modeTimer = 0, modeIndex = 0, globalMode = 'scatter';

        // Frightened state
        var frightenedActive = false, frightenedTimer = 0, frightenedDuration = 6000, ghostsEatenThisPellet = 0;

        // Ghost eaten freeze
        var ghostEatenFreeze = 0, ghostEatenPts = 0, ghostEatenIdx = -1, ghostEatenCol = 0, ghostEatenRow = 0;

        // Ready state
        var readyTimer = 0, isFirstLife = true;

        // Intermission
        var intermissionTimer = 0, intermissionType = '', intermissionText = '';

        // Floating texts (WAKA WAKA, scores)
        var floatingTexts = [];
        var dotsEatenSinceWaka = 0;

        // Fruit / ingredient
        var fruit = null, fruitTimer = 0, fruitSpawned = 0;

        // Level / Score
        var level = 1;
        var highScore = parseInt(localStorage.getItem('slaw-man-high')) || 0;
        var stateTimer = 0, deathTimer = 0;

        // Init
        function initGame() {
            level = 1;
            player.score = 0;
            player.lives = 3;
            player.extraLifeGiven = false;
            isFirstLife = true;
            initLevel();
            state = READY;
            readyTimer = 2500;
        }

        function initLevel() {
            resetMaze();
            resetPlayer();
            resetGhosts();
            modeTimer = 0;
            modeIndex = 0;
            globalMode = 'scatter';
            frightenedActive = false;
            frightenedTimer = 0;
            ghostsEatenThisPellet = 0;
            ghostEatenFreeze = 0;
            fruit = null;
            fruitTimer = 0;
            fruitSpawned = 0;
            stateTimer = 0;
            floatingTexts = [];
            dotsEatenSinceWaka = 0;
        }

        // Helpers
        function isWalkable(col, row) {
            if (row < 0 || row >= ROWS) return false;
            if (col < 0 || col >= COLS) { return row === 10; }
            return maze[row][col] !== 0;
        }

        function isWalkableForGhost(col, row) {
            if (row < 0 || row >= ROWS) return false;
            if (col < 0 || col >= COLS) { return row === 10; }
            return MAZE_TEMPLATE[row][col] !== 0;
        }

        function wrapCol(col) {
            if (col < 0) return COLS - 1;
            if (col >= COLS) return 0;
            return col;
        }

        function dist(c1, r1, c2, r2) {
            var dc = c1 - c2, dr = r1 - r2;
            return Math.sqrt(dc * dc + dr * dr);
        }

        function showToast(msg) {
            var el = document.createElement('div');
            el.className = 'toast';
            el.textContent = msg;
            document.getElementById('toastContainer').appendChild(el);
            setTimeout(function() { el.remove(); }, 2300);
        }

        // Ghost AI — classic Pac-Man targeting
        function getGhostTarget(ghost) {
            if (ghost.mode === 'scatter') return ghost.corner;
            if (ghost.mode === 'frightened') return null; // random
            if (ghost.mode === 'eyes') return { col: 11, row: 10 };

            // Chase mode
            switch (ghost.idx) {
                case 0: // Mayonnaise (Blinky) — direct chase
                    return { col: player.col, row: player.row };
                case 1: // Ranch (Pinky) — 4 tiles ahead
                    return { col: player.col + DX[player.dir] * 4, row: player.row + DY[player.dir] * 4 };
                case 2: // Raisin (Inky) — uses Blinky's position, reflects through 2 ahead
                    var ahead = { col: player.col + DX[player.dir] * 2, row: player.row + DY[player.dir] * 2 };
                    var blinky = ghosts[0];
                    return { col: ahead.col + (ahead.col - blinky.col), row: ahead.row + (ahead.row - blinky.row) };
                case 3: // Thousand Island (Clyde) — shy, scatter when close
                    if (dist(ghost.col, ghost.row, player.col, player.row) < 8) return ghost.corner;
                    return { col: player.col, row: player.row };
                default:
                    return { col: player.col, row: player.row };
            }
        }

        function moveGhost(ghost, dt) {
            ghost.moveTimer += dt;
            var speed = ghost.moveInterval;
            if (ghost.mode === 'frightened') speed = 230;
            if (ghost.mode === 'eyes') speed = 80;
            // Speed up with levels
            speed = Math.max(80, speed - (level - 1) * 8);
            if (ghost.mode === 'frightened') speed = Math.max(150, 230 - (level - 1) * 5);
            // Elroy mode for Mayonnaise — speeds up when few dots remain
            if (ghost.idx === 0 && ghost.mode !== 'frightened' && ghost.mode !== 'eyes' && ghost.mode !== 'house') {
                var remaining = totalDots - dotsEaten;
                if (remaining <= 7) speed = Math.max(60, speed - 50);
                else if (remaining <= 15) speed = Math.max(70, speed - 30);
            }

            if (ghost.moveTimer < speed) return;
            ghost.moveTimer = 0;

            // Ghost house exit
            if (ghost.mode === 'house') {
                ghost.houseTimer -= speed;
                if (ghost.houseTimer <= 0) {
                    ghost.col = 11;
                    ghost.row = 9;
                    ghost.mode = globalMode;
                    ghost.dir = 3;
                }
                return;
            }

            // Eyes reached home
            if (ghost.mode === 'eyes' && ghost.col === 11 && ghost.row === 10) {
                ghost.mode = globalMode;
                return;
            }

            var target = getGhostTarget(ghost);
            var bestDir = -1, bestDist = Infinity;
            var reverse = (ghost.dir + 2) % 4;
            var dirs = [0, 1, 2, 3];

            // Shuffle for random movement (frightened / Inky-style)
            if (target === null) {
                for (var i = dirs.length - 1; i > 0; i--) {
                    var j = Math.floor(Math.random() * (i + 1));
                    var tmp = dirs[i]; dirs[i] = dirs[j]; dirs[j] = tmp;
                }
            }

            for (var d = 0; d < dirs.length; d++) {
                var dir = dirs[d];
                if (dir === reverse && ghost.mode !== 'eyes') continue;
                var nc = wrapCol(ghost.col + DX[dir]);
                var nr = ghost.row + DY[dir];
                if (!isWalkableForGhost(nc, nr)) continue;
                // Don't re-enter ghost house unless eyes
                if (ghost.mode !== 'eyes' && ghost.mode !== 'house') {
                    if (nr >= 10 && nr <= 12 && nc >= 8 && nc <= 14 && MAZE_TEMPLATE[nr][nc] === 2) continue;
                }
                if (target === null) { bestDir = dir; break; }
                var d2 = dist(nc, nr, target.col, target.row);
                if (d2 < bestDist) { bestDist = d2; bestDir = dir; }
            }

            if (bestDir === -1) {
                var nc2 = wrapCol(ghost.col + DX[reverse]);
                var nr2 = ghost.row + DY[reverse];
                if (isWalkableForGhost(nc2, nr2)) bestDir = reverse;
                else return;
            }

            ghost.dir = bestDir;
            ghost.col = wrapCol(ghost.col + DX[bestDir]);
            ghost.row = ghost.row + DY[bestDir];
        }

        // Player movement
        function movePlayer(dt) {
            player.moveTimer += dt;
            var speed = Math.max(80, player.moveInterval - (level - 1) * 5);
            if (player.moveTimer < speed) return;
            player.moveTimer = 0;

            var nc = wrapCol(player.col + DX[player.nextDir]);
            var nr = player.row + DY[player.nextDir];
            if (isWalkable(nc, nr)) {
                player.dir = player.nextDir;
                player.col = nc;
                player.row = nr;
            } else {
                nc = wrapCol(player.col + DX[player.dir]);
                nr = player.row + DY[player.dir];
                if (isWalkable(nc, nr)) { player.col = nc; player.row = nr; }
            }

            // Eat dots
            if (player.row >= 0 && player.row < ROWS && player.col >= 0 && player.col < COLS) {
                var cell = maze[player.row][player.col];
                if (cell === 1) {
                    maze[player.row][player.col] = 2;
                    player.score += 10;
                    dotsEaten++;
                    dotsEatenSinceWaka++;
                    if (dotsEatenSinceWaka >= 10) {
                        dotsEatenSinceWaka = 0;
                        floatingTexts.push({ x: player.col * CELL + CELL / 2, y: player.row * CELL, text: 'WAKA WAKA', timer: 800 });
                    }
                } else if (cell === 3) {
                    maze[player.row][player.col] = 2;
                    player.score += 50;
                    dotsEaten++;
                    activateFrightened();
                }
            }

            // Eat ingredient (fruit)
            if (fruit && player.col === fruit.col && player.row === fruit.row) {
                player.score += fruit.pts;
                floatingTexts.push({ x: fruit.col * CELL + CELL / 2, y: fruit.row * CELL, text: '+' + fruit.pts, timer: 1000 });
                fruit = null;
            }

            // Extra life at 10000
            if (!player.extraLifeGiven && player.score >= 10000) {
                player.lives++;
                player.extraLifeGiven = true;
                showToast('Extra Life!');
            }

            // High score
            if (player.score > highScore) {
                highScore = player.score;
                localStorage.setItem('slaw-man-high', highScore);
            }

            // Level complete
            if (dotsEaten >= totalDots) {
                state = LEVEL_COMPLETE;
                stateTimer = 2000;
            }
        }

        function activateFrightened() {
            frightenedActive = true;
            frightenedDuration = Math.max(2000, 6000 - (level - 1) * 500);
            frightenedTimer = frightenedDuration;
            ghostsEatenThisPellet = 0;
            for (var i = 0; i < ghosts.length; i++) {
                if (ghosts[i].mode !== 'house' && ghosts[i].mode !== 'eyes') {
                    ghosts[i].mode = 'frightened';
                    ghosts[i].frightenedTimer = frightenedDuration;
                    ghosts[i].dir = (ghosts[i].dir + 2) % 4;
                }
            }
        }

        // Collision
        function checkCollisions() {
            for (var i = 0; i < ghosts.length; i++) {
                var g = ghosts[i];
                if (g.mode === 'house' || g.mode === 'eyes') continue;
                if (g.col === player.col && g.row === player.row) {
                    if (g.mode === 'frightened') {
                        ghostsEatenThisPellet++;
                        var pts = 200 * Math.pow(2, ghostsEatenThisPellet - 1);
                        player.score += pts;
                        g.mode = 'eyes';
                        ghostEatenFreeze = 500;
                        ghostEatenPts = pts;
                        ghostEatenIdx = i;
                        ghostEatenCol = g.col;
                        ghostEatenRow = g.row;
                        if (player.score > highScore) {
                            highScore = player.score;
                            localStorage.setItem('slaw-man-high', highScore);
                        }
                    } else {
                        state = DYING;
                        deathTimer = 1500;
                        return;
                    }
                }
            }
        }

        // Update loop
        var lastTime = 0;

        function update(timestamp) {
            if (!lastTime) lastTime = timestamp;
            var dt = timestamp - lastTime;
            lastTime = timestamp;
            if (dt > 100) dt = 100;

            // Update floating texts
            for (var f = floatingTexts.length - 1; f >= 0; f--) {
                floatingTexts[f].timer -= dt;
                floatingTexts[f].y -= dt * 0.02;
                if (floatingTexts[f].timer <= 0) floatingTexts.splice(f, 1);
            }

            if (state === READY) {
                readyTimer -= dt;
                if (readyTimer <= 0) {
                    state = PLAYING;
                    isFirstLife = false;
                }
            }

            if (state === PLAYING) {
                // Ghost eaten freeze
                if (ghostEatenFreeze > 0) {
                    ghostEatenFreeze -= dt;
                    draw();
                    requestAnimationFrame(update);
                    return;
                }

                // Mode timer
                if (!frightenedActive) {
                    modeTimer += dt;
                    var schedule = MODE_SCHEDULE[modeIndex];
                    if (schedule && modeTimer >= schedule.duration) {
                        modeTimer = 0;
                        modeIndex = Math.min(modeIndex + 1, MODE_SCHEDULE.length - 1);
                        globalMode = MODE_SCHEDULE[modeIndex].mode;
                        for (var i = 0; i < ghosts.length; i++) {
                            if (ghosts[i].mode === 'chase' || ghosts[i].mode === 'scatter') {
                                ghosts[i].dir = (ghosts[i].dir + 2) % 4;
                                ghosts[i].mode = globalMode;
                            }
                        }
                    }
                }

                // Frightened timer
                if (frightenedActive) {
                    frightenedTimer -= dt;
                    if (frightenedTimer <= 0) {
                        frightenedActive = false;
                        for (var i2 = 0; i2 < ghosts.length; i2++) {
                            if (ghosts[i2].mode === 'frightened') ghosts[i2].mode = globalMode;
                        }
                    }
                }

                movePlayer(dt);
                for (var g = 0; g < ghosts.length; g++) moveGhost(ghosts[g], dt);
                checkCollisions();

                // Fruit/ingredient spawning
                fruitTimer += dt;
                if (fruitSpawned < 2 && dotsEaten > totalDots * (fruitSpawned === 0 ? 0.3 : 0.6) && !fruit) {
                    var ingIdx = Math.min(level - 1, INGREDIENTS.length - 1);
                    fruit = {
                        col: 11, row: 14,
                        emoji: INGREDIENTS[ingIdx].emoji,
                        pts: INGREDIENTS[ingIdx].pts,
                        timer: 8000
                    };
                    fruitSpawned++;
                }
                if (fruit) {
                    fruit.timer -= dt;
                    if (fruit.timer <= 0) fruit = null;
                }

                // Mouth animation
                player.mouthAngle += player.mouthDir * dt * 0.008;
                if (player.mouthAngle > 0.8) player.mouthDir = -1;
                if (player.mouthAngle < 0.05) player.mouthDir = 1;
            }

            if (state === DYING) {
                deathTimer -= dt;
                if (deathTimer <= 0) {
                    player.lives--;
                    if (player.lives <= 0) {
                        state = GAME_OVER;
                    } else {
                        resetPlayer();
                        resetGhosts();
                        modeTimer = 0;
                        modeIndex = 0;
                        globalMode = 'scatter';
                        frightenedActive = false;
                        ghostEatenFreeze = 0;
                        state = READY;
                        readyTimer = 2000;
                    }
                }
            }

            if (state === LEVEL_COMPLETE) {
                stateTimer -= dt;
                if (stateTimer <= 0) {
                    var prevLevel = level;
                    level++;
                    // Check for intermission
                    if (prevLevel === 2 || prevLevel === 5 || prevLevel === 9) {
                        state = INTERMISSION;
                        intermissionTimer = 4000;
                        if (prevLevel === 2) {
                            intermissionType = 'chase';
                            intermissionText = 'To make great coleslaw, first eliminate the mayo.';
                        } else if (prevLevel === 5) {
                            intermissionType = 'raisin';
                            intermissionText = 'Seriously though, who puts raisins in coleslaw?';
                        } else {
                            intermissionType = 'dressing';
                            intermissionText = 'The vinegar always wins.';
                        }
                    } else {
                        initLevel();
                        state = READY;
                        readyTimer = 2000;
                    }
                }
            }

            if (state === INTERMISSION) {
                intermissionTimer -= dt;
                if (intermissionTimer <= 0) {
                    initLevel();
                    state = READY;
                    readyTimer = 2000;
                }
            }

            draw();
            requestAnimationFrame(update);
        }

        // ══════════════════════════════════════════════
        // DRAWING
        // ══════════════════════════════════════════════

        function drawMaze() {
            // Fill background
            ctx.fillStyle = '#0a0f1a';
            ctx.fillRect(0, 0, W, H);

            // Draw wall outlines (classic thin-line style)
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            for (var r = 0; r < ROWS; r++) {
                for (var c = 0; c < COLS; c++) {
                    if (MAZE_TEMPLATE[r][c] !== 0) continue;
                    var x = c * CELL, y = r * CELL;
                    // Top edge
                    if (r === 0 || MAZE_TEMPLATE[r - 1][c] !== 0) {
                        ctx.moveTo(x, y + 1); ctx.lineTo(x + CELL, y + 1);
                    }
                    // Bottom edge
                    if (r === ROWS - 1 || MAZE_TEMPLATE[r + 1][c] !== 0) {
                        ctx.moveTo(x, y + CELL - 1); ctx.lineTo(x + CELL, y + CELL - 1);
                    }
                    // Left edge (skip tunnel row boundary)
                    if ((c === 0 && r !== 10) || (c > 0 && MAZE_TEMPLATE[r][c - 1] !== 0)) {
                        ctx.moveTo(x + 1, y); ctx.lineTo(x + 1, y + CELL);
                    }
                    // Right edge (skip tunnel row boundary)
                    if ((c === COLS - 1 && r !== 10) || (c < COLS - 1 && MAZE_TEMPLATE[r][c + 1] !== 0)) {
                        ctx.moveTo(x + CELL - 1, y); ctx.lineTo(x + CELL - 1, y + CELL);
                    }
                }
            }
            ctx.stroke();

            // Ghost house door (pink line)
            ctx.strokeStyle = '#f9a8d4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(8 * CELL, 10 * CELL);
            ctx.lineTo(15 * CELL, 10 * CELL);
            ctx.stroke();

            // "MAYO FACTORY" label
            ctx.font = '600 7px Inter';
            ctx.fillStyle = '#475569';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('MAYO FACTORY', 11.5 * CELL, 9.3 * CELL);

            // Tunnel arrows
            ctx.fillStyle = '#334155';
            // Left arrow
            ctx.beginPath();
            ctx.moveTo(3, 10 * CELL + CELL / 2);
            ctx.lineTo(9, 10 * CELL + CELL / 2 - 4);
            ctx.lineTo(9, 10 * CELL + CELL / 2 + 4);
            ctx.closePath();
            ctx.fill();
            // Right arrow
            ctx.beginPath();
            ctx.moveTo(W - 3, 10 * CELL + CELL / 2);
            ctx.lineTo(W - 9, 10 * CELL + CELL / 2 - 4);
            ctx.lineTo(W - 9, 10 * CELL + CELL / 2 + 4);
            ctx.closePath();
            ctx.fill();

            // Draw dots (cabbage shreds) and power pellets (vinegar bombs)
            for (var r2 = 0; r2 < ROWS; r2++) {
                for (var c2 = 0; c2 < COLS; c2++) {
                    if (!maze[r2]) continue;
                    var cx = c2 * CELL + CELL / 2;
                    var cy = r2 * CELL + CELL / 2;

                    if (maze[r2][c2] === 1) {
                        // Cabbage shred — tiny elongated shape
                        ctx.save();
                        ctx.translate(cx, cy);
                        ctx.rotate((r2 * COLS + c2) * 0.7);
                        ctx.fillStyle = '#4ade80';
                        ctx.fillRect(-3, -1, 6, 2);
                        ctx.restore();
                    } else if (maze[r2][c2] === 3) {
                        // Vinegar bomb — pulsing yellow-green orb with V
                        var pulse = 4 + Math.sin(Date.now() * 0.005) * 2;
                        ctx.fillStyle = '#a3e635';
                        ctx.beginPath();
                        ctx.arc(cx, cy, pulse, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = 'bold 8px Inter';
                        ctx.fillStyle = '#0a0f1a';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('V', cx, cy + 1);
                    }
                }
            }
        }

        function drawPlayer() {
            if (state === DYING) {
                // Classic death: mouth opens wider rotating upward, then collapses
                var progress = 1 - (deathTimer / 1500);
                var px = player.col * CELL + CELL / 2;
                var py = player.row * CELL + CELL / 2;
                var r = CELL * 0.45;
                var mouthGap = progress * Math.PI;
                var upAngle = -Math.PI / 2;
                var shrink = progress > 0.7 ? (progress - 0.7) / 0.3 : 0;
                var radius = r * (1 - shrink * 0.8);

                if (mouthGap < Math.PI - 0.05 && radius > 1) {
                    ctx.fillStyle = '#4ade80';
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.arc(px, py, radius, upAngle + mouthGap, upAngle + Math.PI * 2 - mouthGap);
                    ctx.closePath();
                    ctx.fill();
                }
                return;
            }

            // Don't draw player during ghost eaten freeze
            if (ghostEatenFreeze > 0) return;

            var px = player.col * CELL + CELL / 2;
            var py = player.row * CELL + CELL / 2;
            var r = CELL * 0.45;
            var mouth = player.mouthAngle;
            var angles = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
            var angle = angles[player.dir];

            ctx.fillStyle = '#4ade80';
            ctx.beginPath();
            ctx.arc(px, py, r, angle + mouth, angle + Math.PI * 2 - mouth);
            ctx.lineTo(px, py);
            ctx.closePath();
            ctx.fill();

            // Eye
            var eyeAngle = angle - Math.PI / 4;
            var eyeX = px + Math.cos(eyeAngle) * r * 0.4;
            var eyeY = py + Math.sin(eyeAngle) * r * 0.4;
            ctx.fillStyle = '#0a0f1a';
            ctx.beginPath();
            ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawGhostBody(x, y, color, dir, scared) {
            var r = CELL * 0.45;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y - 2, r, Math.PI, 0);
            ctx.lineTo(x + r, y + r - 2);
            var waves = 3, waveW = (r * 2) / waves;
            for (var i = 0; i < waves; i++) {
                var wx = x + r - i * waveW;
                ctx.quadraticCurveTo(wx - waveW * 0.25, y + r + 3, wx - waveW * 0.5, y + r - 2);
                ctx.quadraticCurveTo(wx - waveW * 0.75, y + r - 5, wx - waveW, y + r - 2);
            }
            ctx.closePath();
            ctx.fill();

            if (scared) {
                // Scared face
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(x - 3, y - 3, 1.5, 0, Math.PI * 2);
                ctx.arc(x + 3, y - 3, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fbbf24';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                for (var s = 0; s < 5; s++) {
                    var sx = x - 5 + s * 2.5;
                    var sy = y + 2 + (s % 2 === 0 ? -1 : 1);
                    if (s === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
            } else {
                // Normal eyes looking in direction
                for (var e = -1; e <= 1; e += 2) {
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.ellipse(x + e * 3.5, y - 2, 3.5, 4.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#2563eb';
                    ctx.beginPath();
                    ctx.arc(x + e * 3.5 + DX[dir] * 2, y - 2 + DY[dir] * 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawGhostEyes(x, y, dir) {
            for (var e = -1; e <= 1; e += 2) {
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.ellipse(x + e * 4, y - 2, 4, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#2563eb';
                ctx.beginPath();
                ctx.arc(x + e * 4 + DX[dir] * 2, y - 2 + DY[dir] * 2, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawGhost(ghost) {
            // Skip eaten ghost during freeze (show score instead)
            if (ghostEatenFreeze > 0 && ghost.idx === ghostEatenIdx) {
                ctx.font = '800 12px Inter';
                ctx.fillStyle = '#00ffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(ghostEatenPts, ghostEatenCol * CELL + CELL / 2, ghostEatenRow * CELL + CELL / 2);
                return;
            }

            if (ghost.mode === 'house') {
                var bob = Math.sin(Date.now() * 0.004 + ghost.idx) * 3;
                drawGhostBody(ghost.col * CELL + CELL / 2, ghost.row * CELL + CELL / 2 + bob, ghost.color, ghost.dir, false);
                return;
            }

            var gx = ghost.col * CELL + CELL / 2;
            var gy = ghost.row * CELL + CELL / 2;

            if (ghost.mode === 'eyes') {
                drawGhostEyes(gx, gy, ghost.dir);
                return;
            }

            var color = ghost.color;
            var scared = false;
            if (ghost.mode === 'frightened') {
                scared = true;
                color = frightenedTimer < 2000 && Math.floor(Date.now() / 200) % 2 === 0 ? '#ffffff' : '#2563eb';
            }

            drawGhostBody(gx, gy, color, ghost.dir, scared);
        }

        function drawFruit() {
            if (!fruit) return;
            ctx.font = '14px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(fruit.emoji, fruit.col * CELL + CELL / 2, fruit.row * CELL + CELL / 2);
        }

        function drawFloatingTexts() {
            for (var f = 0; f < floatingTexts.length; f++) {
                var ft = floatingTexts[f];
                var alpha = Math.min(1, ft.timer / 400);
                ctx.font = '600 9px Inter';
                ctx.fillStyle = 'rgba(74, 222, 128, ' + alpha.toFixed(2) + ')';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(ft.text, ft.x, ft.y);
            }
        }

        function drawHUD() {
            ctx.save();
            // 1UP + Score (top-left, drawn over wall row 0)
            ctx.font = '600 10px Inter';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#ef4444';
            ctx.fillText('1UP', 8, 12);
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText(player.score, 40, 12);

            // High score (top-center)
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ef4444';
            ctx.fillText('HIGH SCORE', W / 2, 12);
            ctx.fillStyle = '#e2e8f0';
            ctx.font = '600 9px Inter';
            ctx.fillText(highScore, W / 2, 24);

            // Lives as mini Slaw-Man icons (bottom-left, over wall row 26)
            for (var i = 0; i < player.lives - 1; i++) {
                var lx = 12 + i * 18;
                var ly = ROWS * CELL - 10;
                ctx.fillStyle = '#4ade80';
                ctx.beginPath();
                ctx.arc(lx, ly, 6, Math.PI + 0.3, Math.PI * 3 - 0.3);
                ctx.lineTo(lx, ly);
                ctx.closePath();
                ctx.fill();
            }

            // Level indicator (bottom-right)
            ctx.font = '600 10px Inter';
            ctx.textAlign = 'right';
            ctx.fillStyle = '#94a3b8';
            ctx.fillText('Lv.' + level, W - 8, ROWS * CELL - 6);

            ctx.restore();
        }

        function drawReady() {
            // Show "PLAYER ONE" on first life, always show "READY!"
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (isFirstLife) {
                ctx.font = '600 14px Inter';
                ctx.fillStyle = '#00ffff';
                ctx.fillText('PLAYER ONE', W / 2, 13 * CELL + CELL / 2);
            }
            var blink = Math.sin(Date.now() * 0.006) > -0.3;
            if (blink) {
                ctx.font = '800 18px Inter';
                ctx.fillStyle = '#facc15';
                ctx.fillText('READY!', W / 2, 15 * CELL);
            }
        }

        function drawMenu() {
            ctx.fillStyle = 'rgba(10, 15, 26, 0.9)';
            ctx.fillRect(0, 0, W, H);

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Title
            ctx.font = '800 36px Inter';
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('SLAW-', W / 2 - 40, 60);
            ctx.fillStyle = '#4ade80';
            ctx.fillText('MAN', W / 2 + 55, 60);

            // Subtitle
            ctx.font = '600 11px Inter';
            ctx.fillStyle = '#94a3b8';
            ctx.fillText('CHOMP THE MAZE. AVOID THE CONDIMENTS.', W / 2, 90);

            // Ghost roster
            var gy = 135;
            ctx.font = '600 12px Inter';
            ctx.fillStyle = '#64748b';
            ctx.fillText('— THE CONDIMENTS —', W / 2, gy);
            gy += 25;

            for (var i = 0; i < GHOST_DEFS.length; i++) {
                var gd = GHOST_DEFS[i];
                // Color swatch
                ctx.fillStyle = gd.color;
                ctx.beginPath();
                ctx.arc(W / 2 - 130, gy, 6, 0, Math.PI * 2);
                ctx.fill();
                // Name
                ctx.textAlign = 'left';
                ctx.font = '700 11px Inter';
                ctx.fillStyle = gd.color;
                ctx.fillText(gd.name, W / 2 - 115, gy - 5);
                // Nickname + desc
                ctx.font = '11px Inter';
                ctx.fillStyle = '#64748b';
                ctx.fillText('"' + gd.nick + '" — ' + gd.desc, W / 2 - 115, gy + 9);
                ctx.textAlign = 'center';
                gy += 35;
            }

            // Point values
            gy += 5;
            ctx.font = '600 10px Inter';
            ctx.fillStyle = '#64748b';
            ctx.fillText('— POINT VALUES —', W / 2, gy);
            gy += 18;
            ctx.font = '10px Inter';
            ctx.fillStyle = '#94a3b8';
            ctx.fillText('Cabbage Shred: 10  |  Vinegar Bomb: 50', W / 2, gy);
            gy += 15;
            ctx.fillText('Ghost Chain: 200 \u2192 400 \u2192 800 \u2192 1600', W / 2, gy);
            gy += 15;
            ctx.fillText('Ingredients: 100 \u2013 2000', W / 2, gy);

            // High score
            gy += 30;
            ctx.font = '600 13px Inter';
            ctx.fillStyle = '#94a3b8';
            ctx.fillText('HIGH SCORE: ' + highScore, W / 2, gy);

            // Start prompt
            var blink = Math.sin(Date.now() * 0.004) > 0;
            if (blink) {
                ctx.font = '700 16px Inter';
                ctx.fillStyle = '#4ade80';
                ctx.fillText('PRESS SPACE TO SHRED', W / 2, H - 70);
                ctx.font = '11px Inter';
                ctx.fillStyle = '#64748b';
                ctx.fillText('Tap to Start on Mobile', W / 2, H - 48);
            }
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(10, 15, 26, 0.92)';
            ctx.fillRect(0, 0, W, H);

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Main text
            ctx.font = '800 22px Inter';
            ctx.fillStyle = '#ef4444';
            ctx.fillText('THE SLAW HAS BEEN DRESSED', W / 2, H / 2 - 50);

            // Subtitle
            ctx.font = '13px Inter';
            ctx.fillStyle = '#94a3b8';
            ctx.fillText('The condiments have won... this time.', W / 2, H / 2 - 20);

            // Score
            ctx.font = '600 18px Inter';
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('Score: ' + player.score, W / 2, H / 2 + 20);

            ctx.font = '13px Inter';
            ctx.fillStyle = '#94a3b8';
            ctx.fillText('Level ' + level + ' reached', W / 2, H / 2 + 45);

            ctx.font = '600 13px Inter';
            ctx.fillStyle = '#64748b';
            ctx.fillText('High Score: ' + highScore, W / 2, H / 2 + 70);

            // Retry prompt
            var blink = Math.sin(Date.now() * 0.004) > 0;
            if (blink) {
                ctx.font = '600 14px Inter';
                ctx.fillStyle = '#4ade80';
                ctx.fillText('Press Space for Revenge', W / 2, H / 2 + 110);
            }
        }

        function drawLevelComplete() {
            // Flash the maze walls
            var flash = Math.floor(Date.now() / 200) % 2 === 0;
            if (flash) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                for (var r = 0; r < ROWS; r++) {
                    for (var c = 0; c < COLS; c++) {
                        if (MAZE_TEMPLATE[r][c] !== 0) continue;
                        var x = c * CELL, y = r * CELL;
                        if (r === 0 || MAZE_TEMPLATE[r - 1][c] !== 0) { ctx.moveTo(x, y + 1); ctx.lineTo(x + CELL, y + 1); }
                        if (r === ROWS - 1 || MAZE_TEMPLATE[r + 1][c] !== 0) { ctx.moveTo(x, y + CELL - 1); ctx.lineTo(x + CELL, y + CELL - 1); }
                        if ((c === 0 && r !== 10) || (c > 0 && MAZE_TEMPLATE[r][c - 1] !== 0)) { ctx.moveTo(x + 1, y); ctx.lineTo(x + 1, y + CELL); }
                        if ((c === COLS - 1 && r !== 10) || (c < COLS - 1 && MAZE_TEMPLATE[r][c + 1] !== 0)) { ctx.moveTo(x + CELL - 1, y); ctx.lineTo(x + CELL - 1, y + CELL); }
                    }
                }
                ctx.stroke();
            }
        }

        function drawIntermission() {
            ctx.fillStyle = '#0a0f1a';
            ctx.fillRect(0, 0, W, H);

            var progress = 1 - (intermissionTimer / 4000);
            var cy = H / 2 - 20;

            if (intermissionType === 'chase') {
                // Slaw-Man chases Mayo across screen
                var sx = -20 + progress * (W + 40);
                var gx = sx - 50;
                // Draw ghost (Mayo) fleeing
                drawGhostBody(gx, cy, '#f1f5f9', 2, false);
                // Draw Slaw-Man chasing
                var mouth = 0.3 + Math.sin(Date.now() * 0.01) * 0.2;
                ctx.fillStyle = '#4ade80';
                ctx.beginPath();
                ctx.arc(sx, cy, 12, Math.PI + mouth, Math.PI * 3 - mouth);
                ctx.lineTo(sx, cy);
                ctx.closePath();
                ctx.fill();
            } else if (intermissionType === 'raisin') {
                // Giant raisin rolls across
                var rx = W + 30 - progress * (W + 60);
                ctx.save();
                ctx.translate(rx, cy);
                ctx.rotate(progress * Math.PI * 8);
                ctx.fillStyle = '#a855f7';
                ctx.beginPath();
                ctx.arc(0, 0, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#e9d5ff';
                ctx.font = '800 16px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('?', 0, 0);
                ctx.restore();
            } else if (intermissionType === 'dressing') {
                if (progress < 0.5) {
                    // Ghosts chase Slaw-Man
                    var p = progress * 2;
                    var sx2 = -20 + p * (W * 0.7);
                    ctx.fillStyle = '#4ade80';
                    var m2 = 0.3 + Math.sin(Date.now() * 0.01) * 0.2;
                    ctx.beginPath();
                    ctx.arc(sx2, cy, 12, 0 + m2, Math.PI * 2 - m2);
                    ctx.lineTo(sx2, cy);
                    ctx.closePath();
                    ctx.fill();
                    for (var gi = 0; gi < 4; gi++) {
                        drawGhostBody(sx2 + 30 + gi * 25, cy, GHOST_DEFS[gi].color, 0, false);
                    }
                } else {
                    // Reversal: Slaw-Man chases scared ghosts
                    var p2 = (progress - 0.5) * 2;
                    var sx3 = W * 0.7 - p2 * (W * 0.7 + 20);
                    for (var gi2 = 0; gi2 < 4; gi2++) {
                        drawGhostBody(sx3 - 30 - gi2 * 25, cy, '#2563eb', 2, true);
                    }
                    ctx.fillStyle = '#4ade80';
                    var m3 = 0.3 + Math.sin(Date.now() * 0.01) * 0.2;
                    ctx.beginPath();
                    ctx.arc(sx3, cy, 12, Math.PI + m3, Math.PI * 3 - m3);
                    ctx.lineTo(sx3, cy);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Text
            ctx.font = '600 13px Inter';
            ctx.fillStyle = '#94a3b8';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(intermissionText, W / 2, cy + 60);

            // Level indicator
            ctx.font = '600 11px Inter';
            ctx.fillStyle = '#64748b';
            ctx.fillText('Level ' + (level) + ' incoming...', W / 2, cy + 85);
        }

        function draw() {
            ctx.clearRect(0, 0, W, H);

            if (state === MENU) {
                drawMaze();
                drawMenu();
                return;
            }

            if (state === INTERMISSION) {
                drawIntermission();
                return;
            }

            drawMaze();

            if (state !== DYING || deathTimer > 1200) {
                drawFruit();
            }

            drawPlayer();
            for (var i = 0; i < ghosts.length; i++) {
                if (state === DYING) continue; // Hide ghosts during death
                drawGhost(ghosts[i]);
            }

            drawFloatingTexts();
            drawHUD();

            if (state === READY) drawReady();
            if (state === LEVEL_COMPLETE) drawLevelComplete();
            if (state === GAME_OVER) drawGameOver();
        }

        // ══════════════════════════════════════════════
        // INPUT
        // ══════════════════════════════════════════════

        var dirMap = {
            ArrowRight: 0, ArrowDown: 1, ArrowLeft: 2, ArrowUp: 3,
            d: 0, D: 0, s: 1, S: 1, a: 2, A: 2, w: 3, W: 3
        };

        document.addEventListener('keydown', function(e) {
            if (dirMap[e.key] !== undefined) {
                e.preventDefault();
                if (state === PLAYING) player.nextDir = dirMap[e.key];
            }
            if (e.key === ' ' || e.code === 'Space') {
                e.preventDefault();
                if (state === MENU) {
                    initGame();
                } else if (state === GAME_OVER) {
                    state = MENU;
                }
            }
        });

        // Touch button controls
        function bindTouch(id, dir) {
            var el = document.getElementById(id);
            if (!el) return;
            function handle(e) {
                e.preventDefault();
                if (state === PLAYING) {
                    player.nextDir = dir;
                } else if (state === MENU) {
                    initGame();
                } else if (state === GAME_OVER) {
                    state = MENU;
                }
            }
            el.addEventListener('touchstart', handle, { passive: false });
            el.addEventListener('mousedown', handle);
        }
        bindTouch('btn-right', 0);
        bindTouch('btn-down', 1);
        bindTouch('btn-left', 2);
        bindTouch('btn-up', 3);

        // Swipe detection
        var touchStartX = 0, touchStartY = 0;
        canvas.addEventListener('touchstart', function(e) {
            var t = e.touches[0];
            touchStartX = t.clientX;
            touchStartY = t.clientY;
            if (state === MENU) initGame();
            else if (state === GAME_OVER) state = MENU;
        }, { passive: true });

        canvas.addEventListener('touchend', function(e) {
            var t = e.changedTouches[0];
            var dx = t.clientX - touchStartX;
            var dy = t.clientY - touchStartY;
            var threshold = 20;
            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
                player.nextDir = dx > 0 ? 0 : 2;
            } else if (Math.abs(dy) > threshold) {
                player.nextDir = dy > 0 ? 1 : 3;
            }
        }, { passive: true });

        // Start
        resetMaze();
        requestAnimationFrame(update);
    })();
    </script>
</body>
</html>
